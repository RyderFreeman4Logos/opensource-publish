# Copyright (C) 2025 RyderFreeman4Logos
#
# This program is free software: you can redistribute and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

import os
import json
import re
import subprocess
from datetime import datetime, timezone
# Check if feedgen is installed, if not, we can't run. 
# In the Action environment, we ensure it's installed via action.yml
try:
    from feedgen.feed import FeedGenerator
except ImportError:
    print("Error: 'feedgen' module not found. Please install it.")
    exit(1)

# --- Constants ---
CONFIG_FILE = 'config.json'
MANUSCRIPTS_DIR = 'manuscripts'
CONTENT_DIR = 'content'
FEED_FILE = 'static/feed.xml'
INDEX_FILE = 'content/index.md'

def get_git_info():
    """
    Retrieve repository owner and name from git config or environment variables.
    Useful for constructing the GitHub Pages URL.
    """
    # Try GITHUB_REPOSITORY env var first (available in Actions)
    repo_slug = os.environ.get('GITHUB_REPOSITORY')
    if repo_slug:
        parts = repo_slug.split('/')
        if len(parts) == 2:
            return parts[0], parts[1]
    
    # Fallback to git command
    try:
        result = subprocess.run(['git', 'remote', 'get-url', 'origin'], capture_output=True, text=True)
        url = result.stdout.strip()
        # Parse SSH or HTTPS url
        # git@github.com:Owner/Repo.git
        # https://github.com/Owner/Repo.git
        match = re.search(r'[:/]([\w-]+)/([\w-]+)(?:\.git)?$', url)
        if match:
            return match.group(1), match.group(2)
    except Exception:
        pass
    return None, None

def update_config_urls(config):
    """
    Updates config.json with auto-generated URLs if they are placeholders.
    Returns True if config was modified.
    """
    modified = False
    base_url = config.get('baseSiteUrl', '')
    
    # Check if we need to update
    needs_update = not base_url or 'Âú®Ê≠§Â§ÑÂ°´ÂÜô' in base_url or 'generated by system' in base_url
    
    if needs_update:
        owner, repo = get_git_info()
        if owner and repo:
            new_base_url = f"https://{owner}.github.io/{repo}"
            new_feed_link = f"{new_base_url}/static/feed.xml"
            
            if config.get('baseSiteUrl') != new_base_url or config.get('feedLink') != new_feed_link:
                config['baseSiteUrl'] = new_base_url
                config['feedLink'] = new_feed_link
                modified = True
                print(f"Auto-configured baseSiteUrl: {new_base_url}")
    
    return modified

def get_git_updated_time(filepath):
    """
    Get the last commit timestamp for a file.
    Falls back to filesystem modification time if git fails.
    """
    try:
        # Run git log to get the unix timestamp of the last commit
        result = subprocess.run(
            ['git', 'log', '-1', '--format=%at', '--', filepath],
            capture_output=True, text=True, check=False
        )
        timestamp = result.stdout.strip()
        if timestamp:
            return datetime.fromtimestamp(int(timestamp), tz=timezone.utc)
    except Exception as e:
        print(f"Warning: git log failed for {filepath}: {e}")
    
    return datetime.fromtimestamp(os.path.getmtime(filepath), tz=timezone.utc)

def main():
    """
    Main function to process manuscripts and generate the feed.
    """
    os.makedirs(CONTENT_DIR, exist_ok=True)
    os.makedirs(os.path.dirname(FEED_FILE), exist_ok=True)

    # --- Load Config ---
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            config = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        config = {}

    # --- Auto-Update Config ---
    if update_config_urls(config):
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=4, ensure_ascii=False)
            print("Updated config.json with auto-generated URLs.")
        except Exception as e:
            print(f"Warning: Could not save updated config.json: {e}")

    author_name = config.get('authorName', 'Unknown Author')
    work_title = config.get('workTitle', 'Untitled Work')
    description = config.get('description', '')
    base_site_url = config.get('baseSiteUrl', '').strip('/')
    feed_link = config.get('feedLink', '')

    # --- Load Donation Info ---
    donation_html = ""
    donation_path = os.path.join(MANUSCRIPTS_DIR, 'donation.txt')
    if os.path.exists(donation_path):
        with open(donation_path, 'r', encoding='utf-8') as f:
            raw_donation = f.read()
            # Simple Markdown to HTML conversion for donation info
            # Convert headers
            donation_content = re.sub(r'^### (.*)', r'<h3>\1</h3>', raw_donation, flags=re.MULTILINE)
            donation_content = re.sub(r'^## (.*)', r'<h2>\1</h2>', donation_content, flags=re.MULTILINE)
            donation_content = re.sub(r'^# (.*)', r'<h1>\1</h1>', donation_content, flags=re.MULTILINE)
            # Convert links [text](url)
            donation_content = re.sub(r'\[(.*?)\]\((.*?)\)', r'<a href="\2" target="_blank"></a>', donation_content)
            # Convert code blocks `text`
            donation_content = re.sub(r'`(.*?)`', r'<code>\1</code>', donation_content)
            # Convert newlines to <br> (simple)
            donation_content = donation_content.replace('\n', '<br>')
            
            donation_html = f"""
<div id="donation-section" style="text-align: center; margin: 40px 0;">
    <button onclick="document.getElementById('donation-modal').style.display='block'" 
            style="background-color: #d73a49; color: white; padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold;">
        üéÅ ÊâìËµèÂÇ¨Êõ¥ / Support Author
    </button>
</div>

<div id="donation-modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
    <div style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; position: relative;">
        <span onclick="document.getElementById('donation-modal').style.display='none'" 
              style="color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer;">&times;</span>
        <div style="margin-top: 20px; line-height: 1.6;">
            {donation_content}
        </div>
    </div>
</div>
<script>
// Close the modal when clicking outside of it
window.onclick = function(event) {{
    var modal = document.getElementById('donation-modal');
    if (event.target == modal) {{
        modal.style.display = "none";
    }}
}}
</script>
"""

    # --- Collect Chapters ---
    chapters = []
    
    # Filter and sort files
    files = sorted([f for f in os.listdir(MANUSCRIPTS_DIR) if f.endswith('.txt') and f != 'donation.txt'])

    for filename in files:
        txt_path = os.path.join(MANUSCRIPTS_DIR, filename)
        
        # Regex to extract ID and Title
        # Supports: "001 Title.txt", "001_Title.txt", "001. Title.txt"
        match = re.match(r'^(\d+)[_\.\s]+(.*)\.txt$', filename)
        if not match:
            print(f"Skipping invalid filename format: {filename}")
            continue
        
        chapter_id = match.group(1)
        chapter_title = match.group(2).strip()
        
        # Create a URL-friendly slug
        slug = re.sub(r'[^\w\u4e00-\u9fa5-]', '', chapter_title.replace(' ', '-'))
        # Ensure distinct filename even if titles are same (using ID)
        md_filename = f"{chapter_id}-{slug}.md"
        
        chapters.append({
            'id': chapter_id,
            'title': chapter_title,
            'txt_path': txt_path,
            'md_filename': md_filename,
            'updated_at': get_git_updated_time(txt_path)
        })

    # --- Process Chapters & Generate Content ---
    for i, chapter in enumerate(chapters):
        # Determine Next/Prev
        prev_chapter = chapters[i-1] if i > 0 else None
        next_chapter = chapters[i+1] if i < len(chapters) - 1 else None

        with open(chapter['txt_path'], 'r', encoding='utf-8') as f:
            raw_content = f.read()

        # Better text processing
        # 1. Normalize line endings
        content = raw_content.replace('\r\n', '\n')
        # 2. Split by double newlines (paragraphs)
        paragraphs = [p.strip() for p in content.split('\n\n') if p.strip()]
        # 3. If no double newlines found, try splitting by single newlines (common in some editors)
        if len(paragraphs) <= 1 and len(content) > 100:
             paragraphs = [p.strip() for p in content.split('\n') if p.strip()]

        # Generate Markdown with Front Matter
        md_content = "---\n"
        md_content += f"layout: default\n"
        md_content += f"title: \"{chapter['title']}\"\n"
        md_content += f"date: {chapter['updated_at'].isoformat()}\n"
        md_content += f"author: \"{author_name}\"\n"
        if prev_chapter:
            md_content += f"prev_url: ./ {prev_chapter['md_filename']}\n"
            md_content += f"prev_title: \"{prev_chapter['title']}\"\n"
        if next_chapter:
            md_content += f"next_url: ./ {next_chapter['md_filename']}\n"
            md_content += f"next_title: \"{next_chapter['title']}\"\n"
        md_content += "---\n\n"

        md_content += f"# {chapter['title']}\n\n"
        md_content += "\n\n".join(f"{p}" for p in paragraphs)
        
        # Add Donation Section BEFORE the navigation
        if donation_html:
            md_content += f"\n\n{donation_html}\n\n"
        
        # Add navigation footer
        md_content += "\n\n---\n\n"
        md_content += "<div class=\"navigation\">\n"
        if prev_chapter:
            md_content += f"  <a href=\"./{prev_chapter['md_filename']}\">‚Üê {prev_chapter['title']}</a>\n"
        else:
            md_content += "  <span></span>\n"
            
        md_content += f"  <a href=\"./index.md\">ÁõÆÂΩï</a>\n"
        
        if next_chapter:
            md_content += f"  <a href=\"./{next_chapter['md_filename']}\">{next_chapter['title']} ‚Üí</a>\n"
        else:
            md_content += "  <span></span>\n"
        md_content += "</div>\n"

        # Write MD file
        md_path = os.path.join(CONTENT_DIR, chapter['md_filename'])
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(md_content)
        
        print(f"Generated {chapter['md_filename']}")

    # --- Generate Index (Table of Contents) ---
    index_content = "---\n"
    index_content += "layout: default\n"
    index_content += f"title: \"{work_title}\"\n"
    index_content += "---\n\n"
    index_content += f"# {work_title}\n\n"
    if description:
        index_content += f"*{description}*\n\n"
    index_content += "---\n\n"
    index_content += "## ÁõÆÂΩï\n\n"
    
    for chapter in chapters:
        index_content += f"- [{chapter['title']}](./{chapter['md_filename']})\n"
        
    with open(INDEX_FILE, 'w', encoding='utf-8') as f:
        f.write(index_content)
    print("Generated index.md")

    # --- Generate Atom Feed ---
    fg = FeedGenerator()
    fg.id(base_site_url or 'urn:uuid:00000000')
    fg.title(work_title)
    fg.author({'name': author_name})
    if base_site_url:
        fg.link(href=base_site_url, rel='alternate')
    if feed_link:
        fg.link(href=feed_link, rel='self')
    fg.subtitle(f'Latest chapters of {work_title}')
    fg.language('zh-CN')

    # Add entries (reverse chronological for feed is usually better, but for books ID order is also fine. 
    # Let's stick to ID order but maybe standard readers expect newest first? 
    # Actually for a book, you want the "newest published chapter" at the top usually.)
    for chapter in reversed(chapters):
        fe = fg.add_entry()
        entry_url = f"{base_site_url}/content/{chapter['md_filename']}" if base_site_url else f"urn:chapter:{chapter['id']}"
        fe.id(entry_url)
        fe.title(chapter['title'])
        fe.link(href=entry_url)
        
        # Read back the content we just wrote to get the HTML-ish markdown
        # Note: In a real robust setup we'd convert MD to HTML here for the feed content.
        # For now, we will provide a summary link.
        fe.summary(f"New chapter available: {chapter['title']}. Click to read.")
        fe.updated(chapter['updated_at'])

    fg.atom_file(FEED_FILE, pretty=True)
    print(f"Generated feed at '{FEED_FILE}'")

if __name__ == "__main__":
    main()
